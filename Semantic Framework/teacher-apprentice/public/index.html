<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Semantic Centroid Dashboard</title>
  <script src="https://cdn.plot.ly/plotly-2.29.1.min.js"></script>
  <style>
    body {
      font-family: Arial, Helvetica, sans-serif;
      margin: 20px;
      max-width: 1600px
    }

    h1 {
      text-align: center;
      margin-bottom: .5em
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px
    }

    .col {
      display: flex;
      flex-direction: column;
      gap: 18px
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 4px
    }

    .btn-row {
      display: flex;
      gap: 12px
    }

    label {
      font-weight: bold
    }

    input,
    button {
      font-size: 1em;
      padding: 10px
    }

    input {
      width: 100%;
      box-sizing: border-box
    }

    button {
      cursor: pointer
    }

    .panel {
      background: #f9f9f9;
      border: 2px solid #000;
      padding: 10px;
      min-height: 160px;
      white-space: pre-wrap;
      overflow-y: auto
    }

    #tsnePlot {
      width: 100%;
      height: 400px
    }
  </style>
</head>

<body>
  <h1>
    Semantic Centroid Dashboard
    <span id="modelBadge" style="font-size:.65em;padding:.2em .5em;margin-left:.5em;
               background:#e67e22;color:#fff;border-radius:4px">
      training…
    </span>
  </h1>

  <datalist id="peersList"></datalist>

  <div class="grid">
    <!-- left column --------------------------------------------------->
    <div class="col">
      <div class="field">
        <label for="sendAddr">SEND IP/PORT</label>
        <input id="sendAddr" list="peersList" placeholder="e.g. localhost:3001">
      </div>

      <div class="field">
        <label for="entryBox">SENDING DATA</label>
        <input id="entryBox" placeholder="Type text to send …">
      </div>

      <div class="field">
        <label>RECEIVED DATA LOG</label>
        <div id="receivedData" class="panel">(no teacher data yet)</div>
      </div>

      <div class="field">
        <label>KNOWLEDGE BASE (Tokens)</label>
        <div id="rawData" class="panel">(loading…)</div>
      </div>
    </div>

    <!-- right column -------------------------------------------------->
    <div class="col">
      <div class="field">
        <label for="myAddr">MY IP/PORT</label>
        <input id="myAddr" readonly>
      </div>

      <div class="btn-row">
        <button id="sendBtn">SEND</button>
        <button id="clearBtn" style="background:#e74c3c;color:#fff">Clear KB</button>
      </div>

      <div class="field">
        <label>CURRENT CENTROIDS</label>
        <div id="currCentroids" class="panel">(none yet)</div>
      </div>

      <div class="field">
        <label>PREDICTED CENTROIDS</label>
        <div id="predCentroids" class="panel">(none yet)</div>
      </div>

      <button id="predictBtn" style="width:max-content;align-self:flex-start">
        Predict Future Centroids
      </button>

      <div class="field" style="padding:0">
        <label>t-SNE Vis.</label>
        <div class="panel" style="padding:0;border:none">
          <div id="tsnePlot"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* DOM --------------------------------------------------------------*/
    const rawDiv = document.getElementById('rawData');
    const currDiv = document.getElementById('currCentroids');
    const predDiv = document.getElementById('predCentroids');
    const recDiv = document.getElementById('receivedData');

    const sendAddr = document.getElementById('sendAddr');
    const entryBox = document.getElementById('entryBox');
    const myAddr = document.getElementById('myAddr');

    const sendBtn = document.getElementById('sendBtn');
    const clearBtn = document.getElementById('clearBtn');
    const predictBtn = document.getElementById('predictBtn');

    const peersList = document.getElementById('peersList');
    const badge = document.getElementById('modelBadge');

    myAddr.value = window.location.host;

    /* peer discovery ---------------------------------------------------*/
    function rememberPeer(p) {
      if (!p) return;
      const list = JSON.parse(localStorage.getItem('peers') || '[]');
      if (!list.includes(p)) { list.push(p); localStorage.setItem('peers', JSON.stringify(list)); }
    }
    async function refreshPeers() {
      const peers = JSON.parse(localStorage.getItem('peers') || '[]');
      peersList.innerHTML = '';
      for (const peer of peers) {
        let live = false;
        try { live = (await fetch(`http://${peer}/ping`, { mode: 'cors' })).ok; } catch { }
        const opt = document.createElement('option');
        opt.value = peer; opt.label = `${peer} ${live ? '✓' : '✗'}`;
        peersList.appendChild(opt);
      }
    }
    refreshPeers(); setInterval(refreshPeers, 10000);

    /* handy ------------------------------------------------------------*/
    const NO_STORE = { cache: 'no-store' };

    /* dashboard refreshers --------------------------------------------*/
    function fmtCentroids(obj, labels = {}) {
      /* obj  : { "1": [...100 num...], "2": [...] }
         labels : { "1": "apple", "2": "banana" }   */

      if (!obj || !Object.keys(obj).length) return '';

      let out = '';
      for (const [id, vec] of Object.entries(obj)) {
        if (!Array.isArray(vec) || !vec.length) continue;        // skip empties
        const lbl = labels[id] || `C${id}`;
        const five = vec.slice(0, 5).map(v =>
          Number.isFinite(v) ? v.toFixed(4) : 'NaN'
        ).join(', ');
        out += `C${id} (${lbl}): [${five}…]\n`;
      }
      return out.trim();
    }
    async function loadKB() {
      const r = await fetch(`/knowledge_base_${window.location.port}.json`, NO_STORE);
      if (!r.ok) return;
      const { rawData, centroids, centroidLabels,
        receivedData, futureCentroids } = await r.json();

      rawDiv.textContent = rawData.length ? rawData.join(', ') : '(no data yet)';
      currDiv.textContent = Object.keys(centroids).length
        ? fmtCentroids(centroids, centroidLabels)
        : '(none yet)';
      if (Object.keys(futureCentroids).length) {
        predDiv.textContent = fmtCentroids(futureCentroids, centroidLabels);
      }
      recDiv.textContent = receivedData.length
        ? receivedData.join('\n')
        : '(no teacher data yet)';
    }
    async function loadTSNE() {
      const r = await fetch(`/tsne_data_${window.location.port}.json`, NO_STORE);
      if (!r.ok) return;
      const { tokens, coords, centroid_labels, centroid_coords } = await r.json();
      Plotly.newPlot('tsnePlot', [
        {
          x: coords.map(p => p[0]), y: coords.map(p => p[1]),
          text: tokens, mode: 'markers+text', textposition: 'top center',
          marker: { size: 8, color: 'blue' }, name: 'Tokens'
        },
        {
          x: centroid_coords.map(p => p[0]), y: centroid_coords.map(p => p[1]),
          text: centroid_labels, mode: 'markers+text', textposition: 'bottom center',
          marker: { size: 12, symbol: 'x', color: 'red' }, name: 'Centroids'
        }
      ], { margin: { t: 0 }, xaxis: { zeroline: true }, yaxis: { zeroline: true } });
    }
    async function refreshAll() { await loadKB(); await loadTSNE(); }

    /* model-status polling --------------------------------------------*/
    async function pollModelStatus() {
      try {
        const r = await fetch('/model_status', NO_STORE);
        if (!r.ok) return;
        const { ready } = await r.json();
        if (ready) {
          badge.textContent = 'ready'; badge.style.background = '#27ae60';
        } else {
          badge.textContent = 'training…'; badge.style.background = '#e67e22';
        }
      } catch { }
    }
    pollModelStatus(); setInterval(pollModelStatus, 3000);

/* actions ----------------------------------------------------------*/
async function sendData () {
  const text = entryBox.value.trim();
  if (!text) return;

  /* ---------- 1. local  /send  ---------- */
  const locResp = await fetch('/send', {
    method : 'POST',
    headers: { 'Content-Type': 'application/json' },
    body   : JSON.stringify({ data: text })
  });
  if (!locResp.ok) { alert('Local /send failed'); return; }

  /* reply shape = { centroids:{…}, hitLabels:[ 'C1(Nature)', … ] } */
  const { hitLabels = [] } = await locResp.json();

  /* ---------- 2. optional remote forward ---------- */
  const remote = sendAddr.value.trim();
  if (remote && remote !== window.location.host && hitLabels.length) {
    let url = remote.startsWith('http') ? remote : `http://${remote}`;
    if (!url.endsWith('/')) url += '/';
    try {
      const f = await fetch(url + 'receive', {
        method : 'POST',
        headers: { 'Content-Type': 'application/json' },
        body   : JSON.stringify({ centroids: hitLabels })
      });
      if (f.ok) rememberPeer(remote);
    } catch (e) {
      console.warn('Remote forward failed', e.message);
      rememberPeer(remote);
    }
  }

  entryBox.value = '';
  await refreshAll();
}

    async function clearAll() {
      if (!confirm('Really clear ALL local data?')) return;
      await fetch('/clear', { method: 'POST' });
      await refreshAll();
    }
    async function predictFuture() {
      const r = await fetch('/predict', { method: 'POST' });
      if (!r.ok) {
        let msg = 'Prediction failed';
        try { const j = await r.json(); if (j.error) msg += ': ' + j.error; } catch { }
        alert(msg);
        return;
      }
      await refreshAll();
    }


    /* event wiring -----------------------------------------------------*/
    sendBtn.addEventListener('click', sendData);
    clearBtn.addEventListener('click', clearAll);
    predictBtn.addEventListener('click', predictFuture);
    entryBox.addEventListener('keypress', e => e.key === 'Enter' && sendData());

    /* first paint ------------------------------------------------------*/
    refreshAll(); setInterval(refreshAll, 5000);
  </script>
</body>

</html>