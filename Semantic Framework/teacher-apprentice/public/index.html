<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Semantic Centroid Dashboard</title>
  <script src="https://cdn.plot.ly/plotly-2.29.1.min.js"></script>

  <style>
    /* ------- layout shell ------------------------------------------- */
    :root {
      --radius: 12px;
      --border: #d0d4d9;
      --bg-card: #f7f8fa;
      --gap: 22px;
    }

    body {
      font-family: Arial, Helvetica, sans-serif;
      margin: 20px;
      max-width: 1700px;
    }

    h1 {
      text-align: center;
      margin-bottom: .8em
    }

    /* raised “section” card */
    .card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: 0 3px 8px rgba(0, 0, 0, .06);
      padding: 25px 28px;
      margin-bottom: 40px;
    }

    .card>h2 {
      margin-top: 0;
      margin-bottom: 18px;
      font-size: 1.3em;
      letter-spacing: .02em;
      text-align: center;
    }

    /* inside-card grid (two columns) */
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--gap);
    }

    .col {
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    /* common form parts --------------------------------------------- */
    .field {
      display: flex;
      flex-direction: column;
      gap: .4em
    }

    .btn-row {
      display: flex;
      gap: 14px
    }

    label {
      font-weight: bold;
      font-size: .9em
    }

    input,
    button {
      font-size: 1em;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
    }

    input {
      width: 100%;
      box-sizing: border-box;
    }

    button {
      background: #fff;
      cursor: pointer;
      transition: .15s;
    }

    button:hover {
      background: #ebeff3
    }

    /* data panels ---------------------------------------------------- */
    .panel {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 12px;
      min-height: 160px;
      white-space: pre-wrap;
      overflow-y: auto;
    }

    /* plot size override */
    #tsnePlot {
      width: 100%;
      height: 400px
    }

    /* status badge */
    #modelBadge {
      font-size: .7em;
      padding: .25em .6em;
      margin-left: .6em;
      border-radius: 6px;
      color: #fff;
      background: #e67e22;
    }
  </style>
</head>

<body>
  <h1>
    Semantic Centroid Dashboard
  </h1>

  <datalist id="peersList"></datalist>

  <!-- ─────────────── TEACHER ─────────────── -->
  <section class="card" id="teacherCard">
    <h2>Teacher</h2>
    <div class="grid">

      <!-- LEFT column -->
      <div class="col">
        <div class="field">
          <label for="sendAddr">SEND IP/PORT</label>
          <input id="sendAddr" list="peersList" placeholder="e.g. localhost:3001">
        </div>

        <div class="field">
          <label for="entryBox">SENDING DATA</label>
          <div class="btn-row">
            <input id="entryBox" placeholder="Type text to send …">
            <button id="sendBtn">SEND</button>
          </div>
        </div>

        <div class="field">
          <label>KNOWLEDGE BASE</label>
          <div id="rawData" class="panel">(loading…)</div>
        </div>

        <button id="clearBtn" style="background:#e74c3c;color:#fff">Clear KB</button>

      </div>

      <!-- RIGHT column -->
      <div class="col">

        <div class="field">
          <label>CURRENT CENTROIDS</label>
          <div id="currCentroids" class="panel">(none yet)</div>
        </div>

        <div class="field">
          <label>t-SNE Vis.</label>
          <div class="panel" style="padding:0">
            <div id="tsnePlot"></div>
          </div>
        </div>
      </div>

    </div> <!-- grid -->
  </section>

  <!-- ─────────────── APPRENTICE ─────────────── -->
  <section class="card" id="apprenticeCard">
    <h2>Apprentice</h2>
    <div class="grid">

      <!-- LEFT column -->
      <div class="col">
        <div class="field">
          <label for="myAddr">MY IP/PORT</label>
          <input id="myAddr" readonly>
        </div>

        <div class="field">
          <label>RECEIVED DATA LOG</label>
          <div id="receivedData" class="panel">(no teacher data yet)</div>
        </div>

        <div class="field">
          <label>PREDICT DATA</label>
          <div id="predCentroids" class="panel">(none yet)</div>
        </div>
        <span id="modelBadge">training…</span>
        <button id="predictBtn" style="width:max-content">Predict Future Centroids </button>

      </div>

      <!-- RIGHT column -->
      <div class="col">
        <div class="field">
          <label>CURRENT CENTROIDS</label>
          <div id="currCentroids" class="panel">(none yet)</div>
        </div>

        <div class="field">
          <label>t-SNE Vis.</label>
          <div class="panel" style="padding:0">
            <div id="tsnePlotApprentice"></div>
          </div>
        </div>
      </div>

    </div> <!-- grid -->
  </section>

  <script>
    /* DOM --------------------------------------------------------------*/
    const rawDiv = document.getElementById('rawData');
    const currDiv = document.getElementById('currCentroids');
    const predDiv = document.getElementById('predCentroids');
    const recDiv = document.getElementById('receivedData');

    const sendAddr = document.getElementById('sendAddr');
    const entryBox = document.getElementById('entryBox');
    const myAddr = document.getElementById('myAddr');

    const sendBtn = document.getElementById('sendBtn');
    const clearBtn = document.getElementById('clearBtn');
    const predictBtn = document.getElementById('predictBtn');

    const peersList = document.getElementById('peersList');
    const badge = document.getElementById('modelBadge');

    myAddr.value = window.location.host;

    /* peer discovery ---------------------------------------------------*/
    function rememberPeer(p) {
      if (!p) return;
      const list = JSON.parse(localStorage.getItem('peers') || '[]');
      if (!list.includes(p)) { list.push(p); localStorage.setItem('peers', JSON.stringify(list)); }
    }
    async function refreshPeers() {
      const peers = JSON.parse(localStorage.getItem('peers') || '[]');
      peersList.innerHTML = '';
      for (const peer of peers) {
        let live = false;
        try { live = (await fetch(`http://${peer}/ping`, { mode: 'cors' })).ok; } catch { }
        const opt = document.createElement('option');
        opt.value = peer; opt.label = `${peer} ${live ? '✓' : '✗'}`;
        peersList.appendChild(opt);
      }
    }
    refreshPeers(); setInterval(refreshPeers, 10000);

    /* handy ------------------------------------------------------------*/
    const NO_STORE = { cache: 'no-store' };

    /* dashboard refreshers --------------------------------------------*/
    function fmtCentroids(obj, labels = {}) {
      /* obj  : { "1": [...100 num...], "2": [...] }
         labels : { "1": "apple", "2": "banana" }   */

      if (!obj || !Object.keys(obj).length) return '';

      let out = '';
      for (const [id, vec] of Object.entries(obj)) {
        if (!Array.isArray(vec) || !vec.length) continue;        // skip empties
        const lbl = labels[id] || `C${id}`;
        const five = vec.slice(0, 5).map(v =>
          Number.isFinite(v) ? v.toFixed(4) : 'NaN'
        ).join(', ');
        out += `C${id} (${lbl}): [${five}…]\n`;
      }
      return out.trim();
    }
    async function loadKB() {
      const r = await fetch(`/knowledge_base_${window.location.port}.json`, NO_STORE);
      if (!r.ok) return;
      const { rawData, centroids, centroidLabels,
        receivedData, futureCentroids } = await r.json();

      rawDiv.textContent = rawData.length ? rawData.join(', ') : '(no data yet)';
      currDiv.textContent = Object.keys(centroids).length
        ? fmtCentroids(centroids, centroidLabels)
        : '(none yet)';
      if (Object.keys(futureCentroids).length) {
        predDiv.textContent = fmtCentroids(futureCentroids, centroidLabels);
      }
      recDiv.textContent = receivedData.length
        ? receivedData.join('\n')
        : '(no teacher data yet)';
    }
    async function loadTSNE() {
      const r = await fetch(`/tsne_data_${window.location.port}.json`, NO_STORE);
      if (!r.ok) return;
      const { tokens, coords, centroid_labels, centroid_coords } = await r.json();
      Plotly.newPlot('tsnePlot', [
        {
          x: coords.map(p => p[0]), y: coords.map(p => p[1]),
          text: tokens, mode: 'markers+text', textposition: 'top center',
          marker: { size: 8, color: 'blue' }, name: 'Tokens'
        },
        {
          x: centroid_coords.map(p => p[0]), y: centroid_coords.map(p => p[1]),
          text: centroid_labels, mode: 'markers+text', textposition: 'bottom center',
          marker: { size: 12, symbol: 'x', color: 'red' }, name: 'Centroids'
        }
      ], { margin: { t: 0 }, xaxis: { zeroline: true }, yaxis: { zeroline: true } });
    }
    async function refreshAll() { await loadKB(); await loadTSNE(); }

    /* model-status polling --------------------------------------------*/
    async function pollModelStatus() {
      try {
        const r = await fetch('/model_status', NO_STORE);
        if (!r.ok) return;
        const { ready } = await r.json();
        if (ready) {
          badge.textContent = 'ready'; badge.style.background = '#27ae60';
        } else {
          badge.textContent = 'training…'; badge.style.background = '#e67e22';
        }
      } catch { }
    }
    pollModelStatus(); setInterval(pollModelStatus, 3000);

    /* actions ----------------------------------------------------------*/

    /* actions ----------------------------------------------------------*/
    async function sendData() {
      const text = entryBox.value.trim();
      if (!text) return;

      const locResp = await fetch('/send', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ data: text })
      });
      if (!locResp.ok) { alert('Local /send failed'); return; }

      const { centroids = {}, hitLabels = [] } = await locResp.json();

      const remote = sendAddr.value.trim();
      if (remote && remote !== window.location.host && hitLabels.length) {

        /* 2-a  subset of vectors + label map */
        const subset = {};
        const subsetNames = {};
        for (const lbl of hitLabels) {
          const m = /^C(\d+)\((.+)\)/.exec(lbl);
          if (!m) continue;
          const id = m[1], name = m[2];
          if (centroids[id]) {
            subset[id] = centroids[id];
            subsetNames[id] = name;
          }
        }

        if (Object.keys(subset).length) {
          let url = remote.startsWith('http') ? remote : `http://${remote}`;
          if (!url.endsWith('/')) url += '/';

          await fetch(url + 'receive', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              centroids: subset,
              labels: subsetNames,
              pretty: hitLabels              // for the apprentice log
            })
          }).catch(e => console.warn('Remote forward failed:', e.message));

          rememberPeer(remote);
        }
      }

      entryBox.value = '';
      await refreshAll();
    }


    async function clearAll() {
      if (!confirm('Really clear ALL local data?')) return;
      await fetch('/clear', { method: 'POST' });
      await refreshAll();
    }
    async function predictFuture() {
      const r = await fetch('/predict', { method: 'POST' });
      if (!r.ok) {
        let msg = 'Prediction failed';
        try { const j = await r.json(); if (j.error) msg += ': ' + j.error; } catch { }
        alert(msg);
        return;
      }
      await refreshAll();
    }


    /* event wiring -----------------------------------------------------*/
    sendBtn.addEventListener('click', sendData);
    clearBtn?.addEventListener('click', clearAll);
    predictBtn.addEventListener('click', predictFuture);
    entryBox.addEventListener('keypress', e => e.key === 'Enter' && sendData());

    /* first paint ------------------------------------------------------*/
    refreshAll(); setInterval(refreshAll, 5000);
  </script>
</body>

</html>